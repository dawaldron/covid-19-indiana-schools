// All material copyright ESRI, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.20/esri/copyright.txt for details.
//>>built
define("exports ../../geometry ../../core/Error ../../core/unitUtils ./geodesicConstants ../Polyline ../Polygon ../Point ../SpatialReference".split(" "),function(A,R,y,K,v,N,O,P,Q){function L(a){if(!a)return null;if(a.isGeographic&&a.wkid){var b=v.spheroids[a.wkid];if(b)return b}return a.wkt&&((a=v.WKT_SPHEROID_REGEX.exec(a.wkt))&&2===a.length?(b=a[1].split(","),!b||3>b.length?a=null:(a=parseFloat(b[1]),b=parseFloat(b[2]),a=isNaN(a)||isNaN(b)?null:{a,f:0===b?0:1/b})):a=null,a)?a:null}function H(a){a=
L(a||Q.WGS84);if("b"in a&&"eSq"in a&&"radius"in a)return a;const b=a.a*(1-a.f);return Object.assign(a,{b,eSq:1-(b/a.a)**2,radius:(2*a.a+b)/3,densificationRatio:1E4/((2*a.a+b)/3)})}function I(a,b,e){const {a:c,eSq:d}=H(e);e=Math.sqrt(d);const f=Math.sin(b[1]*v.toRadians);b=c*b[0]*v.toRadians;e=0<d?c*(1-d)*(f/(1-d*f*f)-1/(2*e)*Math.log((1-e*f)/(1+e*f)))*.5:c*f;a[0]=b;a[1]=e;return a}function E(a){return null!==L(a)}function M(a,b){if("polyline"!==a.type&&"polygon"!==a.type)throw new y("geodesic-densify:invalid-geometry",
"the input geometry is neither polyline nor polygon");const {spatialReference:e}=a;if(!E(e))throw new y("geodesic-densify:invalid-spatial-reference","the input geometry spatial reference is not supported");var c="polyline"===a.type?a.paths:a.rings;const d=[],f=[0,0],t={distance:null};for(const m of c){c=[];d.push(c);c.push([m[0][0],m[0][1]]);var h=m[0][0],g=m[0][1];let n,p;for(let k=0;k<m.length-1;k++){n=m[k+1][0];p=m[k+1][1];if(h===n&&g===p)continue;const q=[h,g];J(t,[h,g],[n,p],e);const {azimuth:l,
distance:r}=t;h=r/b;if(1<h){for(g=1;g<=h-1;g++)G(f,q,l,g*b,e),c.push(f.slice(0));G(f,q,l,(r+Math.floor(h-1)*b)/2,e);c.push(f.slice(0))}G(f,q,l,r,e);c.push(f.slice(0));h=f[0];g=f[1]}}return"polyline"===a.type?new N({paths:d,spatialReference:e}):new O({rings:d,spatialReference:e})}function G(a,b,e,c,d){const f=b[0]*v.toRadians;b=b[1]*v.toRadians;e*=v.toRadians;const {a:t,b:h,f:g}=H(d);d=Math.sin(e);e=Math.cos(e);var m=(1-g)*Math.tan(b);b=1/Math.sqrt(1+m*m);const n=m*b,p=Math.atan2(m,e);m=b*d;const k=
m*m;var q=1-k,l=q*(t*t-h*h)/(h*h);const r=1+l/16384*(4096+l*(-768+l*(320-175*l))),F=l/1024*(256+l*(-128+l*(74-47*l)));l=c/(h*r);let B=2*Math.PI,u,z,w,D;for(;1E-12<Math.abs(l-B);)w=Math.cos(2*p+l),u=Math.sin(l),z=Math.cos(l),D=F*u*(w+F/4*(z*(-1+2*w*w)-F/6*w*(-3+4*u*u)*(-3+4*w*w))),B=l,l=c/(h*r)+D;c=n*u-b*z*e;q=g/16*q*(4+g*(4-3*q));c=Math.atan2(n*z+b*u*e,(1-g)*Math.sqrt(k+c*c))/v.toRadians;a[0]=(f+(Math.atan2(u*d,b*z-n*u*e)-(1-q)*g*m*(l+q*u*(w+q*z*(-1+2*w*w)))))/v.toRadians;a[1]=c;return a}function J(a,
b,e,c){var d=b[0]*v.toRadians;b=b[1]*v.toRadians;var f=e[0]*v.toRadians;e=e[1]*v.toRadians;const {a:t,b:h,f:g,radius:m}=H(c),n=f-d;var p=Math.atan((1-g)*Math.tan(b)),k=Math.atan((1-g)*Math.tan(e));c=Math.sin(p);p=Math.cos(p);const q=Math.sin(k);k=Math.cos(k);let l=1E3,r=n,F,B,u;let z,w,D;do{var x=Math.sin(r);var C=Math.cos(r);u=Math.sqrt(k*x*k*x+(p*q-c*k*C)*(p*q-c*k*C));if(0===u)return a.distance=0,a.azimuth=void 0,a.reverseAzimuth=void 0,a;C=c*q+p*k*C;z=Math.atan2(u,C);w=p*k*x/u;B=1-w*w;x=C-2*c*
q/B;isNaN(x)&&(x=0);D=g/16*B*(4+g*(4-3*B));F=r;r=n+(1-D)*g*w*(z+D*u*(x+D*C*(-1+2*x*x)))}while(1E-12<Math.abs(r-F)&&0<--l);if(0===l)return c=Math.acos(Math.sin(b)*Math.sin(e)+Math.cos(b)*Math.cos(e)*Math.cos(f-d))*m,d=f-d,a.azimuth=Math.atan2(Math.sin(d)*Math.cos(e),Math.cos(b)*Math.sin(e)-Math.sin(b)*Math.cos(e)*Math.cos(d))/v.toRadians,a.distance=c,a.reverseAzimuth=void 0,a;d=B*(t*t-h*h)/(h*h);b=d/1024*(256+d*(-128+d*(74-47*d)));f=Math.atan2(p*Math.sin(r),p*q*Math.cos(r)-c*k);a.azimuth=Math.atan2(k*
Math.sin(r),p*q-c*k*Math.cos(r))/v.toRadians;a.distance=h*(1+d/16384*(4096+d*(-768+d*(320-175*d))))*(z-b*u*(x+b/4*(C*(-1+2*x*x)-b/6*x*(-3+4*u*u)*(-3+4*x*x))));a.reverseAzimuth=f/v.toRadians;return a}A.directGeodeticSolver=G;A.geodesicAreas=function(a,b="square-meters"){if(a.some(f=>!E(f.spatialReference)))throw new y("geodesic-areas:invalid-spatial-reference","the input geometries spatial reference is not supported");const e=[];for(var c=0;c<a.length;c++){var d=a[c];const {radius:f,densificationRatio:t}=
H(d.spatialReference);e.push(M(d,f*t))}a=[];c=[0,0];d=[0,0];for(let f=0;f<e.length;f++){const {rings:t,spatialReference:h}=e[f];let g=0;for(let m=0;m<t.length;m++){const n=t[m];I(c,n[0],h);I(d,n[n.length-1],h);let p=d[0]*c[1]-c[0]*d[1];for(let k=0;k<n.length-1;k++)I(c,n[k+1],h),I(d,n[k],h),p+=d[0]*c[1]-c[0]*d[1];g+=p}g=K.convertUnit(g,"square-meters",b);a.push(g/-2)}return a};A.geodesicDensify=M;A.geodesicDistance=function(a,b,e="meters"){if(!a||!b)throw new y("geodesic-distance:missing-parameters",
"one or both input parameters are missing");if(!a.spatialReference||!b.spatialReference)throw new y("geodesic-distance:invalid-parameters","one or both input points do not have a spatial reference");if(!a.spatialReference.equals(b.spatialReference))throw new y("geodesic-distance:invalid-parameters","spatial references of input parameters do not match");const {spatialReference:c}=a;if(!E(c))throw new y("geodesic-distance:not-supported","input geometry spatial reference is not supported");if(a.equals(b))return{distance:0,
azimuth:0,reverseAzimuth:0};const d={distance:null};J(d,[a.x,a.y],[b.x,b.y],c);d.distance=K.convertUnit(d.distance,"meters",e);return d};A.geodesicLengths=function(a,b="meters"){if(!a)throw new y("geodesic-lengths:invalid-geometries","the input geometries type is not supported");if(a.some(d=>!E(d.spatialReference)))throw new y("geodesic-lengths:invalid-spatial-reference","the input geometries spatial reference is not supported");const e=[];for(let d=0;d<a.length;d++){var c=a[d];const {spatialReference:f}=
c;c="polyline"===c.type?c.paths:c.rings;let t=0;for(let h=0;h<c.length;h++){const g=c[h];let m=0;for(let n=1;n<g.length;n++){const p=g[n-1][0],k=g[n][0],q=g[n-1][1],l=g[n][1];if(q!==l||p!==k){const r={distance:null};J(r,[p,q],[k,l],f);m+=r.distance}}t+=m}t=K.convertUnit(t,"meters",b);e.push(t)}return e};A.inverseGeodeticSolver=J;A.isSupported=E;A.pointFromDistance=function(a,b,e){if(!a||null==b||null==e)throw new y("point-from-distance:missing-parameters","one or more input parameters are missing or undefined");
if(0>e||360<e)throw new y("point-from-distance:-of-bounds","azimuth is restricted to angles between, and including, 0\u00b0 to 360\u00b0 degrees");if(!a.spatialReference)throw new y("point-from-distance:missing-spatial-reference","the input point must have a spatial reference");const {spatialReference:c}=a;if(!E(c))throw new y("geodesic-distance:not-supported","input geometry spatial reference is not supported");const d=[0,0];G(d,[a.x,a.y],e,b,c);return new P({x:d[0],y:d[1],spatialReference:c})};
Object.defineProperty(A,"__esModule",{value:!0})});