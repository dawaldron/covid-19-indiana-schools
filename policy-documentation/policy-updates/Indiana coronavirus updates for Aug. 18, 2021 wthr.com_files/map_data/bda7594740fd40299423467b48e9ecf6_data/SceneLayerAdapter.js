// All material copyright ESRI, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.20/esri/copyright.txt for details.
//>>built
define("../../../chunks/_rollupPluginBabelHelpers ../../../chunks/tslib.es6 ../../../Graphic ../../../core/arrayUtils ../../../core/Error ../../../core/maybe ../../../core/promiseUtils ../../../core/watchUtils ../../../core/accessorSupport/decorators/property ../../../core/has ../../../core/accessorSupport/ensureType ../../../core/Logger ../../../core/jsonMap ../../../core/accessorSupport/decorators/subclass ../../../layers/support/fieldUtils ../../../rest/support/FeatureSet ../../statistics/support/utils ../utils ./FeatureLayerAdapter ./LayerAdapter ./support/utils".split(" "),
function(u,z,A,B,q,E,v,F,G,w,O,P,Q,H,x,C,I,J,K,L,t){w=function(D){function y(a){return D.call(this,a)||this}u._inheritsLoose(y,D);var k=y.prototype;k._hasCachedStatistics=function(a){return this.layer.hasCachedStatistics(a)};k._updateQuery=function(a,b=[],c=[]){if(!c.length)return a;const d=this.layer.objectIdField;a=a.clone();b=b.filter(e=>{e=this.layer.getField(e);return-1===c.indexOf(e.name)});const f=b.some(e=>this.layer.getField(e).name===d);a.outFields=f?b:[...b,d];return a};k._fetchFeaturesFromMemory=
function(){var a=u._asyncToGenerator(function*(b,c,d){if(!b)throw new q("scene-layer-adapter:insufficient-data","view is required to fetch the features from layerView");b=yield b.whenLayerView(this.layer);var f=v.createAbortController();const e=F.whenFalseOnce(b,"updating",f.signal);yield v.timeout(e,5E3,f);f=yield t.getMissingFields(this,d,b);c=this._updateQuery(c,d,f);c=(yield b.queryFeatures(c)).features;return f.length?b.whenGraphicAttributes(c,f):c});return function(b,c,d){return a.apply(this,
arguments)}}();k._fetchFeaturesJSONFromMemory=function(){var a=u._asyncToGenerator(function*(b,c,d){return this._fetchFeaturesFromMemory(b,c,d).then(t.ensureFeaturesJSON)});return function(b,c,d){return a.apply(this,arguments)}}();k._fetchFeaturesForStats=function(a){return J.getFieldsList({field:a.field,normalizationField:a.normalizationField,valueExpression:a.valueExpression}).then(b=>this.getSampleFeatures({sampleSize:-1,view:a.view,returnGeometry:a.returnGeometry,requiredFields:b,signal:a.signal}))};
k._generateFeatureSetForCachedHistogram=function(a,b=a.minimum,c=a.maximum,d){const f=[];for(var e=0;e<d;e++)f[e]=0;e=a.counts.length;const m=a.minimum,l=a.maximum;for(let g=0;g<e;g++){var h=(g+.5)/e;h=((1-h)*m+h*l-b)/(c-b)*d;0<=h&&h<=d&&(f[h===d?d-1:Math.floor(h)]+=a.counts[g])}const n=[];f.forEach((g,p)=>{const r=new A({attributes:{}});r.attributes.EXPR_1=p+1;r.attributes.countOFExpr=g;n.push(r)});a=new C;a.features=n;return a};k._getCachedStatistics=function(a,b){const c=this.layer;return a.valueExpression||
a.sqlExpression||a.sqlWhere||a.minValue||a.maxValue?Promise.reject(new q("scene-layer-adapter:not-supported","This Layer does not support calculating statistics when 'valueExpression', 'sqlExpression', 'sqlWhere', 'minValue' or 'maxValue' is specified")):c.queryCachedStatistics(b&&b.name,{signal:a.signal}).then(d=>{d=d.stats;const {min:f,max:e,totalValuesCount:m}=d;let {avg:l,stddev:h,sum:n,variance:g,count:p}=d;if(0!==f||0!==e)l=0===l?null:l,n=0===n?null:n,h=0===h?null:h,g=0===g?null:g,p=0===p?null:
p;null==p&&(null!=n&&null!=l?p=Math.round(n/l):null!=m&&(p=m));return{avg:l,count:p,max:e,min:f,stddev:h,sum:n,variance:g}})};k._getSummaryStatisticsFromMemory=function(){var a=u._asyncToGenerator(function*(b,c){var d={field:b.field,valueExpression:b.valueExpression,normalizationField:b.normalizationField,view:b.view,signal:b.signal};d=b.features?b.features:yield this._fetchFeaturesForStats(d);if(!d||!d.length)throw new q("scene-layer-adapter:insufficient-data","No features are available to calculate statistics");
c=x.isDateField(c);b={...b};if("percent-of-total"===b.normalizationType){const f=(yield t.calculateStatsFromMemory({field:b.field},d)).sum;if(null==f)throw new q("scene-layer-adapter:invalid","invalid normalizationTotal");b.normalizationTotal=f}d=yield t.calculateStatsFromMemory(b,d,c);return t.processSummaryStatisticsResult(d)});return function(b,c){return a.apply(this,arguments)}}();k._getCachedStatisticsForUniqueValues=function(a,b){const c=this.layer,d=b&&b.name,f=b&&this.getFieldDomain(a.field);
return a.valueExpression||a.sqlExpression||a.sqlWhere?Promise.reject(new q("scene-layer-adapter:not-supported","This Layer does not support calculating statistics when 'valueExpression', 'sqlExpression' or 'sqlWhere' is specified")):c.queryCachedStatistics(d,{signal:a.signal}).then(e=>{var m=e.stats;if(!m.mostFrequentValues)return Promise.reject();e=e.labels&&e.labels.labels;const l={},h=[],n="countOF"+d;m.mostFrequentValues.forEach(g=>{const p=new A({attributes:{}});p.attributes[d]=b&&b.name!==c.objectIdField&&
(x.isNumericField(b)||x.isDateField(b))?Number(g.value):g.value;p.attributes[n]=g.count;h.push(p)});e&&e.forEach(g=>{l[g.value]=g.label});m=new C;m.features=h;return t.getUniqueValuesFromFeatureSet(m,this,a.field,l,a.signal)}).then(e=>t.createUVResult(e,f,a.returnAllCodedValues))};k._getUniqueValuesFromMemory=function(a,b){const c=b&&this.getFieldDomain(a.field);b={field:a.field,valueExpression:a.valueExpression,view:a.view,signal:a.signal};return(a.features?Promise.resolve(a.features):this._fetchFeaturesForStats(b)).then(d=>
t.calculateUniqueValuesFromMemory(a,d,c))};k._getCachedStatisticsForHistogram=function(a,b){const c=this.layer;return a.valueExpression||a.sqlExpression||a.sqlWhere||a.normalizationType?Promise.reject(new q("scene-layer-adapter:not-supported","This Layer does not support calculating statistics when 'valueExpression' or 'sqlExpression' or 'sqlWhere' or 'normalizationType' is specified")):c.queryCachedStatistics(b&&b.name,{signal:a.signal}).then(d=>{var f=d.stats;const {minValue:e,maxValue:m}=a;d=null!=
e?e:f.min;const l=null!=m?m:f.max,h=a.numBins||10;f=this._generateFeatureSetForCachedHistogram(f.histogram,d,l,h);return t.getHistogramFromFeatureSet(f,d,l,h)})};k._getClassBreaksFromMemory=function(){var a=u._asyncToGenerator(function*(b){var c={field:b.field,valueExpression:b.valueExpression,normalizationField:b.normalizationField,view:b.view,signal:b.signal};c=b.features?b.features:yield this._fetchFeaturesForStats(c);if(!c||!c.length)throw new q("scene-layer-adapter:insufficient-data","No features are available to calculate statistics");
b={...b};if("percent-of-total"===b.normalizationType){const d=(yield t.calculateStatsFromMemory({field:b.field},c)).sum;if(null==d)throw new q("scene-layer-adapter:invalid","invalid normalizationTotal");b.normalizationTotal=d}return t.calculateClassBreaksFromMemory(b,c)});return function(b){return a.apply(this,arguments)}}();k._getHistogramFromMemory=function(a){const b={field:a.field,valueExpression:a.valueExpression,normalizationField:a.normalizationField,view:a.view,signal:a.signal};return(a.features?
Promise.resolve(a.features):this._fetchFeaturesForStats(b)).then(c=>{if(!c||!c.length)throw new q("scene-layer-adapter:insufficient-data","No features are available to calculate histogram");const {field:d,normalizationType:f,valueExpression:e,classificationMethod:m,minValue:l,maxValue:h,view:n}=a;var g=null!=l&&null!=h;let p=null;m&&"equal-interval"!==m||f?(g={...a},g.features=c,p=this._getBinParamsFromMemory(g)):p=g?Promise.resolve({min:l,max:h}):this.summaryStatistics({field:d,valueExpression:e,
features:c,view:n,signal:a.signal}).then(r=>r.count?{min:r.min,max:r.max}:Promise.reject(new q("feature-layer-adapter:insufficient-data","No features are available to calculate histogram")));return p.then(r=>t.calculateHistogramFromMemory(a,r,c))})};k._getBinParamsFromMemory=function(){var a=u._asyncToGenerator(function*(b){const {field:c,valueExpression:d,classificationMethod:f,standardDeviationInterval:e,normalizationType:m,normalizationField:l,minValue:h,maxValue:n,features:g,view:p}=b;return this._getClassBreaksFromMemory({field:c,
valueExpression:d,normalizationType:m,normalizationField:l,classificationMethod:f,standardDeviationInterval:e,minValue:h,maxValue:n,numClasses:b.numBins,features:g,view:p}).then(r=>{const M=r.normalizationTotal;r=r.classBreakInfos;const N=I.getSQLFilterForNormalization({field:c,normalizationType:m,normalizationField:l});return t.generateBinParams({field:c,normalizationType:m,normalizationField:l,normalizationTotal:M,classBreaks:r,where:N,layer:this})})});return function(b){return a.apply(this,arguments)}}();
k.getField=function(a=""){return this.layer.getField(a)};k.getFieldUsageInfo=function(a){a=this.getField(a);if(!a)return null;a=this.layer.getFieldUsageInfo(a.name);return{supportsLabelingInfo:a.supportsLabelingInfo,supportsPopupTemplate:a.supportsPopupTemplate,supportsRenderer:a.supportsRenderer,supportsLayerQuery:a.supportsLayerQuery,supportsStatistics:!0}};k.getFieldDomain=function(a,b){return this._featureLayerAdapter?this._featureLayerAdapter.getFieldDomain(a,b):null};k.summaryStatistics=function(a){const b=
this.getField(a.field);return this._featureLayerAdapter?this._featureLayerAdapter.summaryStatistics(a):this._hasCachedStatistics(b&&b.name)?this._getCachedStatistics(a,b).catch(()=>{v.throwIfAborted(a.signal);return this._getSummaryStatisticsFromMemory(a,b)}):this._getSummaryStatisticsFromMemory(a,b)};k.uniqueValues=function(a){const b=this.getField(a.field);return this._featureLayerAdapter?this._featureLayerAdapter.uniqueValues(a):this._hasCachedStatistics(b&&b.name)?this._getCachedStatisticsForUniqueValues(a,
b).catch(()=>{v.throwIfAborted(a.signal);return this._getUniqueValuesFromMemory(a,b)}):this._getUniqueValuesFromMemory(a,b)};k.histogram=function(a){const b=this.getField(a.field);return this._featureLayerAdapter?this._featureLayerAdapter.histogram(a):this._hasCachedStatistics(b&&b.name)?this._getCachedStatisticsForHistogram(a,b).catch(()=>{v.throwIfAborted(a.signal);return this._getHistogramFromMemory(a)}):this._getHistogramFromMemory(a)};k.classBreaks=function(a){const b=this.getField(a.field);
return this._featureLayerAdapter?this._featureLayerAdapter.classBreaks(a):this._hasCachedStatistics(b&&b.name)?Promise.reject(new q("scene-layer-adapter:not-supported","Cached stats not supported")):this._getClassBreaksFromMemory(a)};k.queryFeatureCount=function(a,b){return this._featureLayerAdapter?this._featureLayerAdapter.queryFeatureCount(a,b):Promise.reject(new q("scene-layer-adapter:not-supported","SceneLayer without associated FeatureLayer does not support count query"))};k.generateRenderer=
function(a,b){return this._featureLayerAdapter?this._featureLayerAdapter.generateRenderer(a,b):Promise.reject(new q("scene-layer-adapter:not-supported","SceneLayer without associated FeatureLayer does not support generateRenderer operation"))};k.heatmapStatistics=function(a){return this._featureLayerAdapter?this._featureLayerAdapter.heatmapStatistics(a):Promise.reject(new q("scene-layer-adapter:not-supported","SceneLayer without associated FeatureLayer does not support heatmapStatistics operation"))};
k.predominantCategories=function(){var a=u._asyncToGenerator(function*(b){if(this._featureLayerAdapter)return this._featureLayerAdapter.predominantCategories(b);throw new q("scene-layer-adapter:not-supported","SceneLayer without associated FeatureLayer does not support predominantCategories");});return function(b){return a.apply(this,arguments)}}();k.getSampleFeatures=function(){var a=u._asyncToGenerator(function*(b,c){const {view:d,sampleSize:f,requiredFields:e,returnGeometry:m,signal:l}=b;var h=
"json"===c;const n=this.layer.createQuery();n.outFields=e;n.returnGeometry=!!m;n.where=null;n.num=f;let g=[];try{if(g=h?yield this._fetchFeaturesJSONFromMemory(d,n,e):yield this._fetchFeaturesFromMemory(d,n,e),g.length&&0<f&&f<=g.length)return B.pickRandom(g,f,1)}catch(p){v.throwIfAborted(l)}h=null;this._featureLayerAdapter&&(b={...b},delete b.view,h=yield this._featureLayerAdapter.getSampleFeatures(b,c));return h&&h.length?h:B.pickRandom(g,g.length,1)});return function(b,c){return a.apply(this,arguments)}}();
k.load=function(a){const b=this.layer.load(a).then(c=>{const d=c.associatedLayer;this.geometryType=c.geometryType;if(E.isSome(d))return this._featureLayerAdapter=new K({layer:d}),this._featureLayerAdapter.load(a).then(()=>{this.objectIdField=this._featureLayerAdapter.objectIdField;this.supportsSQLExpression=this._featureLayerAdapter.supportsSQLExpression;this.minScale=this._featureLayerAdapter.minScale;this.maxScale=this._featureLayerAdapter.maxScale;this.fullExtent=this._featureLayerAdapter.fullExtent});
this.objectIdField=c.objectIdField;this.hasQueryEngine=this.supportsSQLExpression=!1;this.fullExtent=c.fullExtent});this.addResolvingPromise(b);return Promise.resolve(this)};return y}(L);z.__decorate([G.property({constructOnly:!0})],w.prototype,"layer",void 0);return w=z.__decorate([H.subclass("esri.smartMapping.support.adapters.SceneLayerAdapter")],w)});